<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URDF Viewer</title>
    <!-- Load Three.js and wait for it to be ready -->
    <script src="https://unpkg.com/three@0.140.0/build/three.min.js"></script>
    <script>
        // Wait for Three.js to load
        window.addEventListener('load', function() {
            // Load additional scripts after Three.js is ready
            function loadScript(src) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }

            Promise.all([
                loadScript('https://unpkg.com/three@0.140.0/examples/js/loaders/STLLoader.js'),
                loadScript('https://unpkg.com/three@0.140.0/examples/js/loaders/ColladaLoader.js'),
                loadScript('urdfreader.js')
            ]).then(() => {
                // Initialize the viewer after all scripts are loaded
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js failed to load');
                }
                if (typeof THREE.STLLoader === 'undefined') {
                    throw new Error('STLLoader failed to load');
                }
                if (typeof THREE.ColladaLoader === 'undefined') {
                    throw new Error('ColladaLoader failed to load');
                }
                // Initialize the visualizer
                window.visualizer = new URDFVisualizer();
            }).catch(error => {
                console.error('Error loading scripts:', error);
                const debugConsole = document.getElementById('debugConsole');
                if (debugConsole) {
                    const timestamp = new Date().toLocaleTimeString();
                    debugConsole.innerHTML = `<div><span class="timestamp">[${timestamp}]</span> <span class="error">Error loading required scripts: ${error.message}</span></div>`;
                }
            });
        });
    </script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            gap: 20px;
            height: calc(100vh - 40px);
        }
        .controls {
            flex: 0 0 300px;
            min-width: 300px;
            max-width: 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }
        #webgl-container {
            flex: 1;
            min-width: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        #treeStructure {
            margin-top: 20px;
            padding: 10px;
            background: #f8f8f8;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-y: auto;
            max-height: 200px;
            flex-grow: 1;
        }
        select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background: #4CAF50;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 8px;
            transition: background-color 0.3s;
            font-size: 14px;
        }
        button:hover {
            opacity: 0.9;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        #loadingStatus {
            margin-top: 8px;
            color: #666;
            font-size: 12px;
        }
        #meshStatus {
            margin-top: 8px;
            padding: 8px;
            background: #f8f8f8;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-y: auto;
            max-height: 100px;
        }
        #debugConsole {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 150px;
            background: rgba(30, 30, 30, 0.95);
            color: #00ff00;
            font-family: monospace;
            font-size: 11px;
            padding: 8px;
            overflow-y: auto;
            z-index: 1000;
            border-top: 2px solid #333;
            display: block !important;
            visibility: visible !important;
        }
        #debugConsole .timestamp {
            color: #888;
            margin-right: 8px;
            font-size: 10px;
        }
        #debugConsole .error {
            color: #ff4444;
            font-weight: bold;
        }
        #debugConsole .warning {
            color: #ffaa00;
            font-weight: bold;
        }
        #debugConsole .success {
            color: #44ff44;
            font-weight: bold;
        }
        #debugConsole .info {
            color: #00ff00;
        }
        h2 {
            margin: 0 0 16px 0;
            font-size: 18px;
        }
        .controls > div {
            margin-bottom: 12px;
        }
        /* New styles for joint controls */
        #jointControls {
            margin-top: 20px;
            padding: 10px;
            background: #f8f8f8;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
        }
        .joint-control {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }
        .joint-name {
            font-weight: bold;
            margin-right: 10px;
            font-size: 12px;
            flex: 1;
            min-width: 80px;
        }
        .joint-buttons {
            display: flex;
            gap: 3px;
        }
        .joint-buttons button {
            flex: 0 0 auto;
            padding: 3px 6px;
            margin-top: 0;
            font-size: 11px;
            min-width: 30px;
        }
        .decrement {
            background-color: #f44336;
        }
        .increment {
            background-color: #2196F3;
        }
        .joint-angle {
            text-align: right;
            margin-left: 8px;
            font-size: 11px;
            font-family: monospace;
            min-width: 50px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h2>URDF Viewer</h2>
            <div>
                <label for="modelSelect">Select Robot Model:</label>
                <select id="modelSelect">
                    <option value="">Loading models...</option>
                </select>
            </div>
            <button id="loadButton">Load Model</button>
            <div id="loadingStatus"></div>
            <div id="meshStatus"></div>
            
            <!-- New joint controls section -->
            <div id="jointControls" style="display: none;">
                <h3>Joint Controls</h3>
                <div id="jointControlsContainer"></div>
            </div>
            
            <div id="treeStructure"></div>
            <div>
                <button id="animateButton" style="background: #2196F3;">Animate Joints</button>
                <div id="animationStatus"></div>
            </div>
        </div>
        <div id="webgl-container"></div>
    </div>
    <div id="debugConsole"></div>

    <script>
        // Add debug logging functionality
        class DebugLogger {
            constructor() {
                this.console = document.getElementById('debugConsole');
                if (!this.console) {
                    console.error('Debug console element not found!');
                    throw new Error('Debug console element not found');
                }
                this.log('Debug console initialized', 'success');
            }

            log(message, type = 'info') {
                if (!this.console) {
                    console.error('Cannot log, debug console not found:', message);
                    return;
                }
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.innerHTML = `<span class="timestamp">[${timestamp}]</span> <span class="${type}">${message}</span>`;
                this.console.appendChild(entry);
                this.console.scrollTop = this.console.scrollHeight;
                // Also log to browser console
                console.log(`[${type}] ${message}`);
            }

            info(message) { this.log(message, 'info'); }
            success(message) { this.log(message, 'success'); }
            warning(message) { this.log(message, 'warning'); }
            error(message) { this.log(message, 'error'); }
            clear() { this.console.innerHTML = ''; }
        }

        class URDFVisualizer {
            constructor() {
                this.logger = new DebugLogger();
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.robotGroup = null;
                this.urdfReader = new URDFReader();
                this.jointObjects = new Map();
                this.isAnimating = false;
                this.currentJointIndex = 0;
                this.animationTime = 0;
                this.animationDuration = 3.0;
                this.jointAngles = new Map();

                // Initialize loaders after Three.js is loaded
                this.stlLoader = new THREE.STLLoader();
                this.colladaLoader = new THREE.ColladaLoader();
                // Set ColladaLoader options after initialization
                if (this.colladaLoader) {
                    this.colladaLoader.options = { convertUpAxis: true };
                }
                
                this.spherical = {
                    radius: 10,
                    phi: Math.PI / 4,
                    theta: Math.PI / 4
                };

                this.isDragging = false;
                this.previousMousePosition = { x: 0, y: 0 };

                this.init();
                this.setupEventListeners();
                this.loadAvailableModels();
                this.animate();
            }

            init() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf3f4f6);

                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.updateCameraPosition();

                // Renderer
                const container = document.getElementById('webgl-container');
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(this.renderer.domElement);

                // Grid - XY plane since Z is up
                const gridSize = 10; // Consistent grid size
                const gridDivisions = 10; // Consistent grid divisions
                const gridColorCenter = 0x444444; // Darker color for center lines
                const gridColor = 0x888888; // Lighter color for grid lines

                // Create single XY plane grid (horizontal)
                const grid = new THREE.GridHelper(gridSize, gridDivisions, gridColorCenter, gridColor);
                grid.rotation.x = Math.PI / 2; // Rotate to lie on XY plane
                this.scene.add(grid);

                // Add coordinate axes helper
                const axesHelper = new THREE.AxesHelper(5);
                this.scene.add(axesHelper);

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 5, 5);
                this.scene.add(directionalLight);

                // Robot group
                this.robotGroup = new THREE.Group();
                this.scene.add(this.robotGroup);

                // Cube object (will be created when button is clicked)
                this.cube = null;

                // Add load button event listener
                const loadButton = document.getElementById('loadButton');
                if (loadButton) {
                    loadButton.addEventListener('click', () => this.loadSelectedModel());
                    this.logger.info('Load button event listener added');
                } else {
                    this.logger.error('Load button not found in DOM');
                }

                this.setupEventListeners();
                this.loadAvailableModels();
                this.animate();
            }

            setupEventListeners() {
                const container = document.getElementById('webgl-container');
                container.addEventListener('mousedown', this.onMouseDown.bind(this));
                container.addEventListener('mousemove', this.onMouseMove.bind(this));
                container.addEventListener('mouseup', this.onMouseUp.bind(this));
                container.addEventListener('mouseleave', this.onMouseUp.bind(this));
                container.addEventListener('wheel', this.onMouseWheel.bind(this));
                window.addEventListener('resize', this.onWindowResize.bind(this));

                // Add animation button event listener
                const animateButton = document.getElementById('animateButton');
                if (animateButton) {
                    animateButton.addEventListener('click', () => {
                        if (this.isAnimating) {
                            this.stopAnimation();
                        } else {
                            this.startAnimation();
                        }
                    });
                    this.logger.info('Animation button event listener added');
                } else {
                    this.logger.error('Animation button not found in DOM');
                }

                // Add cube button event listeners
                const drawCubeButton = document.getElementById('drawCubeButton');
                const removeCubeButton = document.getElementById('removeCubeButton');
                
                if (drawCubeButton) {
                    drawCubeButton.addEventListener('click', () => {
                        this.drawCube();
                        drawCubeButton.style.display = 'none';
                        removeCubeButton.style.display = 'block';
                    });
                    this.logger.info('Draw cube button event listener added');
                } else {
                    this.logger.error('Draw cube button not found in DOM');
                }
                
                if (removeCubeButton) {
                    removeCubeButton.addEventListener('click', () => {
                        this.removeCube();
                        removeCubeButton.style.display = 'none';
                        drawCubeButton.style.display = 'block';
                    });
                    this.logger.info('Remove cube button event listener added');
                } else {
                    this.logger.error('Remove cube button not found in DOM');
                }
            }

            updateCameraPosition() {
                // Adjust camera position for Z-up coordinate system
                this.camera.position.x = this.spherical.radius * Math.sin(this.spherical.phi) * Math.cos(this.spherical.theta);
                this.camera.position.z = this.spherical.radius * Math.cos(this.spherical.phi); // Use Z for height
                this.camera.position.y = this.spherical.radius * Math.sin(this.spherical.phi) * Math.sin(this.spherical.theta);
                this.camera.up.set(0, 0, 1); // Set Z as up vector
                this.camera.lookAt(0, 0, 0);
            }

            onMouseDown(event) {
                this.isDragging = true;
                const rect = event.target.getBoundingClientRect();
                this.previousMousePosition = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            }

            onMouseMove(event) {
                if (!this.isDragging) return;

                const rect = event.target.getBoundingClientRect();
                const currentPosition = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };

                const deltaMove = {
                    x: currentPosition.x - this.previousMousePosition.x,
                    y: currentPosition.y - this.previousMousePosition.y
                };

                const rotationSpeed = 0.01;
                this.spherical.theta -= deltaMove.x * rotationSpeed;
                this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi + deltaMove.y * rotationSpeed));

                this.updateCameraPosition();
                this.previousMousePosition = currentPosition;
            }

            onMouseUp() {
                this.isDragging = false;
            }

            onMouseWheel(event) {
                event.preventDefault();
                const zoomSpeed = 0.1;
                const minDistance = 2;
                const maxDistance = 20;
                const zoomDelta = event.deltaY * zoomSpeed;
                this.spherical.radius = Math.max(minDistance, Math.min(maxDistance, this.spherical.radius + zoomDelta));
                this.updateCameraPosition();
            }

            onWindowResize() {
                const container = document.getElementById('webgl-container');
                this.camera.aspect = container.clientWidth / container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(container.clientWidth, container.clientHeight);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                if (this.isAnimating) {
                    this.animationTime += 0.016; // Assuming 60fps
                    
                    if (this.animationTime >= this.animationDuration) {
                        this.animationTime = 0;
                        this.currentJointIndex++;
                        
                        if (this.currentJointIndex >= this.jointObjects.size) {
                            this.stopAnimation();
                        } else {
                            this.updateAnimationStatus();
                        }
                    } else {
                        this.updateJointAnimation();
                    }
                }
                
                this.renderer.render(this.scene, this.camera);
            }

            startAnimation() {
                if (!this.jointObjects || this.jointObjects.size === 0) {
                    this.logger.warning('No joints available to animate');
                    return;
                }
                this.isAnimating = true;
                this.currentJointIndex = 0;
                this.animationTime = 0;
                this.animationDuration = 3.0; // Increased duration for smoother animation
                document.getElementById('animateButton').style.background = '#f44336';
                document.getElementById('animateButton').textContent = 'Stop Animation';
                this.updateAnimationStatus();
                this.logger.info('Starting joint animation');
            }

            stopAnimation() {
                this.isAnimating = false;
                document.getElementById('animateButton').style.background = '#2196F3';
                document.getElementById('animateButton').textContent = 'Animate Joints';
                document.getElementById('animationStatus').textContent = '';
                
                // Reset all joints to zero rotation
                this.resetJointAngles();
                
                this.logger.info('Animation stopped');
            }

            updateAnimationStatus() {
                const status = document.getElementById('animationStatus');
                if (this.isAnimating && status) {
                    const jointNames = Array.from(this.jointObjects.keys());
                    const currentJoint = jointNames[this.currentJointIndex];
                    status.textContent = `Animating joint: ${currentJoint}`;
                    this.logger.info(`Currently animating joint: ${currentJoint}`);
                }
            }

            updateJointAnimation() {
                if (!this.isAnimating) return;

                const jointNames = Array.from(this.jointObjects.keys());
                const currentJoint = jointNames[this.currentJointIndex];
                const jointObject = this.jointObjects.get(currentJoint);
                const jointData = this.urdfReader.robot.joints.get(currentJoint);
                
                if (jointObject && jointData) {
                    // Calculate angle based on time
                    const progress = this.animationTime / this.animationDuration;
                    let angle;
                    
                    if (progress < 0.25) {
                        // First quarter: 0 to +45 degrees
                        angle = (progress * 4) * Math.PI / 4;
                    } else if (progress < 0.75) {
                        // Middle half: +45 to -45 degrees
                        angle = ((0.5 - (progress - 0.25) * 2) * Math.PI / 2);
                    } else {
                        // Last quarter: -45 to 0 degrees
                        angle = (-1 + (progress - 0.75) * 4) * Math.PI / 4;
                    }
                    
                    // Get the joint's axis of rotation
                    const axis = jointData.axis || [0, 0, 1];
                    
                    // Reset transformation
                    jointObject.position.set(0, 0, 0);
                    jointObject.quaternion.set(0, 0, 0, 1);
                    jointObject.scale.set(1, 1, 1);
                    
                    // Apply original transform from URDF
                    if (jointData.origin) {
                        const xyz = jointData.origin.xyz || [0, 0, 0];
                        const rpy = jointData.origin.rpy || [0, 0, 0];
                        
                        // Apply position
                        jointObject.position.set(xyz[0], xyz[1], xyz[2]);
                        
                        // Apply original rotation
                        const euler = new THREE.Euler(rpy[0], rpy[1], rpy[2], 'XYZ');
                        jointObject.setRotationFromEuler(euler);
                    }
                    
                    // Apply joint rotation around axis
                    const axisVec = new THREE.Vector3(axis[0], axis[1], axis[2]).normalize();
                    const rotQuat = new THREE.Quaternion();
                    rotQuat.setFromAxisAngle(axisVec, angle);
                    
                    // Combine with existing rotation
                    jointObject.quaternion.multiply(rotQuat);
                    
                    this.logger.info(`Joint ${currentJoint} angle: ${(angle * 180 / Math.PI).toFixed(2)}° around axis [${axis.join(', ')}]`);
                }

                // Update animation time and check for completion
                this.animationTime += 0.016; // Assuming 60fps
                if (this.animationTime >= this.animationDuration) {
                    // Reset current joint to initial transform
                    if (jointObject && jointData) {
                        jointObject.position.set(0, 0, 0);
                        jointObject.quaternion.set(0, 0, 0, 1);
                        jointObject.scale.set(1, 1, 1);
                        
                        if (jointData.origin) {
                            const xyz = jointData.origin.xyz || [0, 0, 0];
                            const rpy = jointData.origin.rpy || [0, 0, 0];
                            
                            jointObject.position.set(xyz[0], xyz[1], xyz[2]);
                            const euler = new THREE.Euler(rpy[0], rpy[1], rpy[2], 'XYZ');
                            jointObject.setRotationFromEuler(euler);
                        }
                    }
                    
                    this.animationTime = 0;
                    this.currentJointIndex++;
                    
                    if (this.currentJointIndex >= this.jointObjects.size) {
                        this.currentJointIndex = 0;
                    }
                    
                    this.updateAnimationStatus();
                }
            }

            clearRobot() {
                while(this.robotGroup.children.length > 0) {
                    this.robotGroup.remove(this.robotGroup.children[0]);
                }
            }

            loadMesh(filename) {
                return new Promise((resolve, reject) => {
                    const placeholder = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const material = new THREE.MeshPhongMaterial({ color: 0x808080 });
                    const mesh = new THREE.Mesh(placeholder, material);

                    const meshPath = `/public/models/meshes/${filename}`;
                    const timestamp = new Date().getTime();
                    this.logger.info(`Loading mesh file: ${filename}`);
                    this.logger.info(`Resolved path: ${meshPath}`);

                    if (filename.toLowerCase().endsWith('.stl')) {
                        this.stlLoader.load(
                            `${meshPath}?t=${timestamp}`,
                            (geometry) => {
                                geometry.computeBoundingBox();
                                const center = new THREE.Vector3();
                                geometry.boundingBox.getCenter(center);
                                geometry.center();
                                
                                // Fix for STL files - ensure proper orientation and scale
                                // STL files often use a different coordinate system than URDF expects
                                mesh.geometry = geometry;
                                
                                // Apply a rotation to correct the orientation
                                // This rotates from STL's coordinate system to match the URDF/DAE coordinate system
                                mesh.rotation.set(-Math.PI/2, 0, 0);
                                
                                mesh.material = new THREE.MeshPhongMaterial({ 
                                    color: 0x808080,
                                    shininess: 30,
                                    specular: 0x111111
                                });
                                
                                this.logger.success(`Successfully loaded STL: ${filename} with coordinate system correction`);
                                resolve(mesh);
                            },
                            (progress) => {
                                if (progress.lengthComputable) {
                                    const percentComplete = (progress.loaded / progress.total) * 100;
                                    this.logger.info(`Loading ${filename}: ${Math.round(percentComplete)}%`);
                                }
                            },
                            (error) => {
                                this.logger.error(`Failed to load STL: ${filename}`);
                                this.logger.error(`Error details: ${error.message}`);
                                reject(error);
                            }
                        );
                    } else if (filename.toLowerCase().endsWith('.dae')) {
                        this.colladaLoader.load(
                            `${meshPath}?t=${timestamp}`,
                            (collada) => {
                                try {
                                    const daeScene = collada.scene;
                                    this.logger.info(`DAE scene loaded for ${filename}`);
                                    
                                    // Apply materials and process meshes
                                    daeScene.traverse((child) => {
                                        if (child instanceof THREE.Mesh) {
                                            child.material = new THREE.MeshPhongMaterial({ 
                                                color: 0x808080,
                                                shininess: 30,
                                                specular: 0x111111
                                            });
                                            // Ensure geometry is properly initialized
                                            if (child.geometry) {
                                                child.geometry.computeBoundingBox();
                                                child.geometry.computeVertexNormals();
                                            }
                                        }
                                    });
                                    
                                    // Center the model
                                    const box = new THREE.Box3().setFromObject(daeScene);
                                    const center = box.getCenter(new THREE.Vector3());
                                    daeScene.position.sub(center);
                                    
                                    this.logger.success(`Successfully loaded DAE: ${filename}`);
                                    resolve(daeScene);
                                } catch (error) {
                                    this.logger.error(`Error processing DAE scene for ${filename}: ${error.message}`);
                                    reject(error);
                                }
                            },
                            (progress) => {
                                if (progress.lengthComputable) {
                                    const percentComplete = (progress.loaded / progress.total) * 100;
                                    this.logger.info(`Loading ${filename}: ${Math.round(percentComplete)}%`);
                                }
                            },
                            (error) => {
                                this.logger.error(`Failed to load DAE: ${filename}`);
                                this.logger.error(`Error details: ${error.message}`);
                                reject(error);
                            }
                        );
                    } else {
                        reject(new Error(`Unsupported file format: ${filename}`));
                    }
                });
            }

            async visualizeRobot(robotData) {
                this.logger.info('Starting robot visualization...');
                this.clearRobot();
                this.jointObjects.clear();
                
                const linkObjects = new Map();
                const meshStatus = document.getElementById('meshStatus');
                meshStatus.textContent = 'Loading meshes...\n';

                // Create visual objects for each link
                for (const [linkName, linkData] of robotData.links) {
                    this.logger.info(`Processing link: ${linkName}`);
                    const linkGroup = new THREE.Group();
                    linkGroup.name = linkName;

                    if (linkData.visual) {
                        this.logger.info(`Link ${linkName} has visual data`);
                        if (linkData.visual.geometry) {
                            this.logger.info(`Link ${linkName} geometry type: ${linkData.visual.geometry.type}`);
                            if (linkData.visual.geometry.type === 'mesh') {
                                const filename = linkData.visual.geometry.filename;
                                this.logger.info(`Link ${linkName} has mesh: ${filename}`);
                                
                                meshStatus.textContent += `Loading ${filename}...\n`;
                                this.logger.info(`Attempting to load mesh for ${linkName}: ${filename}`);
                                
                                try {
                                    const mesh = await this.loadMesh(filename);
                                    
                                    if (linkData.visual.origin) {
                                        const xyz = linkData.visual.origin.xyz || [0, 0, 0];
                                        const rpy = linkData.visual.origin.rpy || [0, 0, 0];
                                        
                                        // For STL files, we need to handle the orientation differently
                                        if (filename.toLowerCase().endsWith('.stl')) {
                                            // The rotation was already applied in loadMesh for STLs
                                            // Just apply the position and any additional rotation from URDF
                                            mesh.position.set(xyz[0], xyz[1], xyz[2]);
                                            
                                            // Create a rotation matrix from the URDF RPY values
                                            const euler = new THREE.Euler(rpy[0], rpy[1], rpy[2], 'XYZ');
                                            const quaternion = new THREE.Quaternion().setFromEuler(euler);
                                            
                                            // Combine with the existing rotation (which corrects the coordinate system)
                                            mesh.quaternion.premultiply(quaternion);
                                        } else {
                                            // For DAE files, apply transform normally
                                            mesh.position.set(xyz[0], xyz[1], xyz[2]);
                                            mesh.rotation.set(rpy[0], rpy[1], rpy[2]);
                                        }
                                        
                                        this.logger.info(`Applied transform to ${linkName}: pos=[${xyz.join(',')}], rot=[${rpy.join(',')}]`);
                                    }

                                    if (linkData.visual.geometry.scale) {
                                        const scale = linkData.visual.geometry.scale;
                                        mesh.scale.set(scale[0], scale[1], scale[2]);
                                        this.logger.info(`Applied scale to ${linkName}: [${scale.join(',')}]`);
                                    }

                                    linkGroup.add(mesh);
                                    meshStatus.textContent += `Added ${filename} to link ${linkName}\n`;
                                    this.logger.success(`Successfully added mesh to link: ${linkName}`);
                                } catch (error) {
                                    meshStatus.textContent += `Failed to load ${filename}: ${error}\n`;
                                    this.logger.error(`Failed to load mesh for link ${linkName}: ${error.message}`);
                                    // Create a placeholder geometry for failed loads
                                    const placeholder = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                                    const material = new THREE.MeshPhongMaterial({ color: 0xff0000 });
                                    const placeholderMesh = new THREE.Mesh(placeholder, material);
                                    linkGroup.add(placeholderMesh);
                                    this.logger.warning(`Added placeholder geometry for ${linkName}`);
                                }
                            } else {
                                this.logger.info(`Link ${linkName} using primitive geometry: ${linkData.visual.geometry.type}`);
                            }
                        } else {
                            this.logger.warning(`Link ${linkName} has visual data but no geometry`);
                        }
                    } else {
                        this.logger.warning(`Link ${linkName} has no visual data`);
                    }

                    linkObjects.set(linkName, linkGroup);
                }

                this.logger.info('Building joint structure...');
                // Build the tree structure
                for (const [jointName, jointData] of robotData.joints) {
                    const parentLink = linkObjects.get(jointData.parent);
                    const childLink = linkObjects.get(jointData.child);

                    if (parentLink && childLink) {
                        this.logger.info(`Processing joint: ${jointName} (${jointData.parent} -> ${jointData.child})`);
                        const jointGroup = new THREE.Group();
                        jointGroup.name = jointName;
                        
                        if (jointData.origin) {
                            const xyz = jointData.origin.xyz || [0, 0, 0];
                            const rpy = jointData.origin.rpy || [0, 0, 0];
                            jointGroup.position.set(xyz[0], xyz[1], xyz[2]);
                            jointGroup.rotation.set(rpy[0], rpy[1], rpy[2]);
                            this.logger.info(`Applied joint transform: pos=[${xyz.join(',')}], rot=[${rpy.join(',')}]`);
                        }

                        jointGroup.add(childLink);
                        parentLink.add(jointGroup);
                        this.jointObjects.set(jointName, jointGroup);

                        const jointAxis = jointData.axis || [1, 0, 0];
                        const axisHelper = new THREE.ArrowHelper(
                            new THREE.Vector3(jointAxis[0], jointAxis[1], jointAxis[2]),
                            new THREE.Vector3(0, 0, 0),
                            0.5,
                            0xff0000
                        );
                        jointGroup.add(axisHelper);
                        this.logger.info(`Added joint axis indicator for ${jointName}: [${jointAxis.join(',')}]`);
                    }
                }

                this.logger.info('Adding root links to scene...');
                for (const rootLink of robotData.rootLinks) {
                    const rootObject = linkObjects.get(rootLink);
                    if (rootObject) {
                        this.robotGroup.add(rootObject);
                        this.logger.success(`Added root link: ${rootLink}`);
                    }
                }

                // Calculate the bounding box of the robot
                const box = new THREE.Box3().setFromObject(this.robotGroup);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                // Get the bottom of the bounding box (lowest Z point)
                const bottomPoint = new THREE.Vector3();
                box.getCenter(bottomPoint);
                bottomPoint.z -= size.z / 2; // Move to the bottom of the bounding box

                // Position the robot so its base is at Z=0 (on the grid) without scaling
                this.robotGroup.position.set(-bottomPoint.x, -bottomPoint.y, -bottomPoint.z);

                this.logger.info(`Positioned robot on base frame at actual size: bottom=[${bottomPoint.x.toFixed(3)},${bottomPoint.y.toFixed(3)},${bottomPoint.z.toFixed(3)}]`);

                // Adjust camera position to accommodate the unscaled robot
                this.spherical.radius = Math.max(maxDim * 1.5, 10); // Set camera distance based on robot size
                this.updateCameraPosition();

                this.camera.position.set(5, 5, 5);
                this.camera.lookAt(this.robotGroup.position);
                this.logger.success('Robot visualization completed');
            }

            async loadAvailableModels() {
                try {
                    this.logger.info('Starting to load URDF models from server...');
                    const timestamp = new Date().getTime();
                    const url = `/api/models?t=${timestamp}`;
                    this.logger.info(`Fetching models from: ${url}`);
                    
                    const response = await fetch(url);
                    this.logger.info(`Server response status: ${response.status} ${response.statusText}`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const text = await response.text();
                    this.logger.info(`Raw server response: ${text}`);
                    
                    if (!text) {
                        throw new Error('Empty response from server');
                    }
                    
                    const models = JSON.parse(text);
                    this.logger.success(`Found ${models.length} URDF models on server`);
                    
                    const select = document.getElementById('modelSelect');
                    if (!select) {
                        throw new Error('Could not find modelSelect element in DOM');
                    }
                    
                    select.innerHTML = '<option value="">Select a model...</option>';
                    
                    if (!Array.isArray(models) || models.length === 0) {
                        this.logger.warning('No URDF models found on server');
                        select.innerHTML = '<option value="">No models available</option>';
                        return;
                    }
                    
                    models.forEach(model => {
                        if (!model.name || !model.urdf) {
                            this.logger.warning(`Invalid model data received: ${JSON.stringify(model)}`);
                            return;
                        }
                        const option = document.createElement('option');
                        option.value = model.urdf;
                        option.textContent = model.name;
                        select.appendChild(option);
                        this.logger.info(`Added model to dropdown: ${model.name}`);
                    });
                    
                    this.logger.success(`Successfully populated dropdown with ${models.length} URDF models`);
                } catch (error) {
                    this.logger.error(`Failed to load models from server: ${error.message}`);
                    const select = document.getElementById('modelSelect');
                    if (select) {
                        select.innerHTML = '<option value="">Error loading models</option>';
                    }
                }
            }

            async loadSelectedModel() {
                const modelSelect = document.getElementById('modelSelect');
                const modelFile = modelSelect ? modelSelect.value : '';
                
                if (!modelFile) {
                    this.logger.warning('No model selected in dropdown');
                    alert('Please select a model first');
                    return;
                }

                const loadingStatus = document.getElementById('loadingStatus');
                const meshStatus = document.getElementById('meshStatus');
                const loadButton = document.getElementById('loadButton');
                
                try {
                    this.logger.info(`Starting to load URDF model: ${modelFile}`);
                    loadingStatus.textContent = 'Loading URDF...';
                    loadButton.disabled = true;
                    meshStatus.textContent = '';

                    // Clear existing robot
                    this.clearRobot();
                    
                    // Reset joint angles
                    this.jointAngles.clear();

                    // Load and parse the URDF
                    this.logger.info('Requesting URDF file from server...');
                    const robotData = await this.urdfReader.loadModelFromFile(modelFile);
                    this.logger.success(`Successfully parsed URDF for robot: ${robotData.name}`);
                    this.logger.info(`Robot has ${robotData.links.size} links and ${robotData.joints.size} joints`);
                    
                    // Display the tree structure
                    this.logger.info('Generating robot tree structure...');
                    document.getElementById('treeStructure').textContent = this.urdfReader.displayTreeStructure();
                    this.logger.success('Robot tree structure generated');
                    
                    // Visualize the robot
                    this.logger.info('Starting robot visualization...');
                    await this.visualizeRobot(robotData);
                    
                    // Create joint control buttons
                    this.createJointControls();

                    loadingStatus.textContent = 'Model loaded successfully';
                    this.logger.success('Robot model fully loaded and visualized');
                } catch (error) {
                    console.error('Error:', error);
                    this.logger.error(`Failed to load model: ${error.message}`);
                    this.logger.error('Stack trace: ' + error.stack);
                    loadingStatus.textContent = 'Error loading model: ' + error.message;
                } finally {
                    loadButton.disabled = false;
                }
            }

            // Add new method to create joint control buttons
            createJointControls() {
                const jointControlsContainer = document.getElementById('jointControlsContainer');
                jointControlsContainer.innerHTML = '';
                
                if (this.jointObjects.size === 0) {
                    jointControlsContainer.innerHTML = '<p>No joints available to control</p>';
                    return;
                }
                
                // Show the joint controls section
                document.getElementById('jointControls').style.display = 'block';
                
                // Initialize joint angles if not already set
                for (const [jointName, jointObject] of this.jointObjects) {
                    if (!this.jointAngles.has(jointName)) {
                        this.jointAngles.set(jointName, 0);
                    }
                }
                
                // Create controls for each joint
                for (const [jointName, jointObject] of this.jointObjects) {
                    const jointData = this.urdfReader.robot.joints.get(jointName);
                    
                    // Skip fixed joints
                    if (jointData.type === 'fixed') {
                        continue;
                    }
                    
                    const jointControlDiv = document.createElement('div');
                    jointControlDiv.className = 'joint-control';
                    
                    const jointNameDiv = document.createElement('div');
                    jointNameDiv.className = 'joint-name';
                    jointNameDiv.textContent = jointName;
                    jointControlDiv.appendChild(jointNameDiv);
                    
                    const jointButtonsDiv = document.createElement('div');
                    jointButtonsDiv.className = 'joint-buttons';
                    
                    // Create decrement button (-2 degrees)
                    const decrementButton = document.createElement('button');
                    decrementButton.className = 'decrement';
                    decrementButton.textContent = '-2°';
                    
                    // Add continuous rotation with mousedown/touchstart events
                    let decrementInterval;
                    decrementButton.addEventListener('mousedown', () => {
                        this.adjustJointAngle(jointName, -2 * Math.PI / 180);
                        decrementInterval = setInterval(() => {
                            this.adjustJointAngle(jointName, -2 * Math.PI / 180);
                        }, 100); // Adjust every 100ms while button is held
                    });
                    
                    // Stop on mouseup/mouseleave/touchend
                    const stopDecrement = () => {
                        if (decrementInterval) {
                            clearInterval(decrementInterval);
                            decrementInterval = null;
                        }
                    };
                    
                    decrementButton.addEventListener('mouseup', stopDecrement);
                    decrementButton.addEventListener('mouseleave', stopDecrement);
                    decrementButton.addEventListener('touchend', stopDecrement);
                    
                    jointButtonsDiv.appendChild(decrementButton);
                    
                    // Create increment button (+2 degrees)
                    const incrementButton = document.createElement('button');
                    incrementButton.className = 'increment';
                    incrementButton.textContent = '+2°';
                    
                    // Add continuous rotation with mousedown/touchstart events
                    let incrementInterval;
                    incrementButton.addEventListener('mousedown', () => {
                        this.adjustJointAngle(jointName, 2 * Math.PI / 180);
                        incrementInterval = setInterval(() => {
                            this.adjustJointAngle(jointName, 2 * Math.PI / 180);
                        }, 100); // Adjust every 100ms while button is held
                    });
                    
                    // Stop on mouseup/mouseleave/touchend
                    const stopIncrement = () => {
                        if (incrementInterval) {
                            clearInterval(incrementInterval);
                            incrementInterval = null;
                        }
                    };
                    
                    incrementButton.addEventListener('mouseup', stopIncrement);
                    incrementButton.addEventListener('mouseleave', stopIncrement);
                    incrementButton.addEventListener('touchend', stopIncrement);
                    
                    jointButtonsDiv.appendChild(incrementButton);
                    
                    jointControlDiv.appendChild(jointButtonsDiv);
                    
                    // Add angle display
                    const jointAngleDiv = document.createElement('div');
                    jointAngleDiv.className = 'joint-angle';
                    jointAngleDiv.id = `angle-${jointName}`;
                    jointAngleDiv.textContent = '0.00°';
                    jointControlDiv.appendChild(jointAngleDiv);
                    
                    jointControlsContainer.appendChild(jointControlDiv);
                }
                
                this.logger.info('Joint control buttons created');
            }
            
            // Add method to adjust joint angle
            adjustJointAngle(jointName, deltaAngle) {
                if (!this.jointObjects.has(jointName)) {
                    this.logger.warning(`Joint ${jointName} not found`);
                    return;
                }
                
                // Stop animation if it's running
                if (this.isAnimating) {
                    this.stopAnimation();
                }
                
                const jointObject = this.jointObjects.get(jointName);
                const jointData = this.urdfReader.robot.joints.get(jointName);
                
                if (!jointObject || !jointData) {
                    this.logger.warning(`Joint data not found for ${jointName}`);
                    return;
                }
                
                // Get current angle and update it
                let currentAngle = this.jointAngles.get(jointName) || 0;
                currentAngle += deltaAngle;
                this.jointAngles.set(jointName, currentAngle);
                
                // Update angle display
                const angleDisplay = document.getElementById(`angle-${jointName}`);
                if (angleDisplay) {
                    angleDisplay.textContent = `${(currentAngle * 180 / Math.PI).toFixed(2)}°`;
                }
                
                // Get the joint's axis of rotation
                const axis = jointData.axis || [0, 0, 1];
                
                // Reset transformation
                jointObject.position.set(0, 0, 0);
                jointObject.quaternion.set(0, 0, 0, 1);
                jointObject.scale.set(1, 1, 1);
                
                // Apply original transform from URDF
                if (jointData.origin) {
                    const xyz = jointData.origin.xyz || [0, 0, 0];
                    const rpy = jointData.origin.rpy || [0, 0, 0];
                    
                    // Apply position
                    jointObject.position.set(xyz[0], xyz[1], xyz[2]);
                    
                    // Apply original rotation
                    const euler = new THREE.Euler(rpy[0], rpy[1], rpy[2], 'XYZ');
                    jointObject.setRotationFromEuler(euler);
                }
                
                // Apply joint rotation around axis
                const axisVec = new THREE.Vector3(axis[0], axis[1], axis[2]).normalize();
                const rotQuat = new THREE.Quaternion();
                rotQuat.setFromAxisAngle(axisVec, currentAngle);
                
                // Combine with existing rotation
                jointObject.quaternion.multiply(rotQuat);
                
                this.logger.info(`Joint ${jointName} angle adjusted to: ${(currentAngle * 180 / Math.PI).toFixed(2)}° around axis [${axis.join(', ')}]`);
            }
            
            // Reset all joint angles
            resetJointAngles() {
                for (const [jointName, angle] of this.jointAngles) {
                    if (angle !== 0) {
                        this.jointAngles.set(jointName, 0);
                        this.adjustJointAngle(jointName, 0);
                    }
                }
                
                // Update all angle displays
                for (const jointName of this.jointAngles.keys()) {
                    const angleDisplay = document.getElementById(`angle-${jointName}`);
                    if (angleDisplay) {
                        angleDisplay.textContent = '0.00°';
                    }
                }
                
                this.logger.info('All joint angles reset to zero');
            }

            // Add methods to draw and remove the cube
            drawCube() {
                // Remove existing cube if any
                this.removeCube();
                
                // Create a 2x2x2 meter cube
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                
                // Create a material with wireframe to see through the cube
                const material = new THREE.MeshPhongMaterial({
                    color: 0x9C27B0,
                    opacity: 0.7,
                    transparent: true,
                    wireframe: false,
                    side: THREE.DoubleSide
                });
                
                // Create the cube mesh
                this.cube = new THREE.Mesh(geometry, material);
                
                // Add wireframe outline
                const wireframe = new THREE.LineSegments(
                    new THREE.EdgesGeometry(geometry),
                    new THREE.LineBasicMaterial({ color: 0xFFFFFF, linewidth: 2 })
                );
                this.cube.add(wireframe);
                
                // Position the cube at the center of the scene
                this.cube.position.set(0, 0, 1); // Position slightly above the grid
                
                // Add the cube to the scene
                this.scene.add(this.cube);
                
                this.logger.success('Added 2x2x2 meter cube to the scene');
            }

            removeCube() {
                if (this.cube) {
                    this.scene.remove(this.cube);
                    this.cube = null;
                    this.logger.info('Removed cube from the scene');
                }
            }
        }
    </script>
</body>
</html> 
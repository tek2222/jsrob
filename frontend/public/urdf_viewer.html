<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URDF Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="urdfreader.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            gap: 20px;
            height: calc(100vh - 40px);
        }
        .controls {
            flex: 0 0 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }
        #webgl-container {
            flex: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        #treeStructure {
            margin-top: 20px;
            padding: 10px;
            background: #f8f8f8;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre;
            overflow-y: auto;
            flex-grow: 1;
        }
        select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            opacity: 0.9;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        #loadingStatus {
            margin-top: 10px;
            color: #666;
            font-size: 0.9em;
        }
        #meshStatus {
            margin-top: 10px;
            padding: 10px;
            background: #f8f8f8;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre;
            overflow-y: auto;
            max-height: 150px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h2>URDF Viewer</h2>
            <div>
                <label for="modelSelect">Select Robot Model:</label>
                <select id="modelSelect">
                    <option value="">Loading models...</option>
                </select>
            </div>
            <button id="loadButton">Load Model</button>
            <div id="loadingStatus"></div>
            <div id="meshStatus"></div>
            <div id="treeStructure"></div>
            <div>
                <button id="animateButton" style="background: #2196F3;">Animate Joints</button>
                <div id="animationStatus"></div>
            </div>
        </div>
        <div id="webgl-container"></div>
    </div>

    <script>
        class URDFVisualizer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.robotGroup = null;
                this.urdfReader = new URDFReader();
                this.jointObjects = new Map();
                this.isAnimating = false;
                this.currentJointIndex = 0;
                this.animationTime = 0;
                this.animationDuration = 2;
                this.jointAngles = new Map();
                this.stlLoader = new THREE.STLLoader();
                
                this.spherical = {
                    radius: 10,
                    phi: Math.PI / 4,
                    theta: Math.PI / 4
                };

                this.isDragging = false;
                this.previousMousePosition = { x: 0, y: 0 };

                this.init();
                this.setupEventListeners();
                this.loadAvailableModels();
                this.animate();
            }

            async loadAvailableModels() {
                try {
                    const timestamp = new Date().getTime();
                    const response = await fetch(`/api/models?t=${timestamp}`);
                    const models = await response.json();
                    const select = document.getElementById('modelSelect');
                    select.innerHTML = '<option value="">Select a model...</option>';
                    models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.urdf;  // Just the filename
                        option.textContent = model.name;
                        select.appendChild(option);
                    });
                } catch (error) {
                    console.error('Error loading models:', error);
                    document.getElementById('loadingStatus').textContent = 'Error loading models list';
                }
            }

            async loadSelectedModel() {
                const modelFile = document.getElementById('modelSelect').value;
                if (!modelFile) {
                    alert('Please select a model first');
                    return;
                }

                const loadingStatus = document.getElementById('loadingStatus');
                const meshStatus = document.getElementById('meshStatus');
                const loadButton = document.getElementById('loadButton');
                
                try {
                    loadingStatus.textContent = 'Loading URDF...';
                    loadButton.disabled = true;
                    meshStatus.textContent = '';

                    // Load and parse the URDF
                    const robotData = await this.urdfReader.loadModelFromFile(modelFile);
                    
                    // Display the tree structure
                    document.getElementById('treeStructure').textContent = this.urdfReader.displayTreeStructure();
                    
                    // Visualize the robot
                    this.visualizeRobot(robotData);

                    loadingStatus.textContent = 'Model loaded successfully';
                } catch (error) {
                    console.error('Error:', error);
                    loadingStatus.textContent = 'Error loading model: ' + error.message;
                } finally {
                    loadButton.disabled = false;
                }
            }

            init() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf3f4f6);

                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.updateCameraPosition();

                // Renderer
                const container = document.getElementById('webgl-container');
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(this.renderer.domElement);

                // Grid - XY plane since Z is up
                const grid = new THREE.GridHelper(20, 20, 0x000000, 0x888888);
                grid.rotation.x = Math.PI / 2; // Rotate grid to XY plane
                this.scene.add(grid);

                // Add coordinate axes helper
                const axesHelper = new THREE.AxesHelper(5);
                this.scene.add(axesHelper);

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 5, 5);
                this.scene.add(directionalLight);

                // Robot group
                this.robotGroup = new THREE.Group();
                this.scene.add(this.robotGroup);

                // Add animation controls
                const controls = document.querySelector('.controls');
                const animationControls = document.createElement('div');
                animationControls.style.marginTop = '20px';
                animationControls.innerHTML = `
                    <button id="animateButton" style="background: #2196F3;">Animate Joints</button>
                    <div id="animationStatus"></div>
                `;
                controls.appendChild(animationControls);

                // Add animation button event listener
                document.getElementById('animateButton').addEventListener('click', () => {
                    if (!this.isAnimating) {
                        this.startAnimation();
                    } else {
                        this.stopAnimation();
                    }
                });
            }

            setupEventListeners() {
                const container = document.getElementById('webgl-container');
                container.addEventListener('mousedown', this.onMouseDown.bind(this));
                container.addEventListener('mousemove', this.onMouseMove.bind(this));
                container.addEventListener('mouseup', this.onMouseUp.bind(this));
                container.addEventListener('mouseleave', this.onMouseUp.bind(this));
                container.addEventListener('wheel', this.onMouseWheel.bind(this));
                window.addEventListener('resize', this.onWindowResize.bind(this));
            }

            updateCameraPosition() {
                // Adjust camera position for Z-up coordinate system
                this.camera.position.x = this.spherical.radius * Math.sin(this.spherical.phi) * Math.cos(this.spherical.theta);
                this.camera.position.z = this.spherical.radius * Math.cos(this.spherical.phi); // Use Z for height
                this.camera.position.y = this.spherical.radius * Math.sin(this.spherical.phi) * Math.sin(this.spherical.theta);
                this.camera.up.set(0, 0, 1); // Set Z as up vector
                this.camera.lookAt(0, 0, 0);
            }

            onMouseDown(event) {
                this.isDragging = true;
                const rect = event.target.getBoundingClientRect();
                this.previousMousePosition = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            }

            onMouseMove(event) {
                if (!this.isDragging) return;

                const rect = event.target.getBoundingClientRect();
                const currentPosition = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };

                const deltaMove = {
                    x: currentPosition.x - this.previousMousePosition.x,
                    y: currentPosition.y - this.previousMousePosition.y
                };

                const rotationSpeed = 0.01;
                this.spherical.theta -= deltaMove.x * rotationSpeed;
                this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi + deltaMove.y * rotationSpeed));

                this.updateCameraPosition();
                this.previousMousePosition = currentPosition;
            }

            onMouseUp() {
                this.isDragging = false;
            }

            onMouseWheel(event) {
                event.preventDefault();
                const zoomSpeed = 0.1;
                const minDistance = 2;
                const maxDistance = 20;
                const zoomDelta = event.deltaY * zoomSpeed;
                this.spherical.radius = Math.max(minDistance, Math.min(maxDistance, this.spherical.radius + zoomDelta));
                this.updateCameraPosition();
            }

            onWindowResize() {
                const container = document.getElementById('webgl-container');
                this.camera.aspect = container.clientWidth / container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(container.clientWidth, container.clientHeight);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                if (this.isAnimating) {
                    this.animationTime += 0.016; // Assuming 60fps
                    
                    if (this.animationTime >= this.animationDuration) {
                        this.animationTime = 0;
                        this.currentJointIndex++;
                        
                        if (this.currentJointIndex >= this.jointObjects.size) {
                            this.stopAnimation();
                        } else {
                            this.updateAnimationStatus();
                        }
                    } else {
                        this.updateJointAnimation();
                    }
                }
                
                this.renderer.render(this.scene, this.camera);
            }

            startAnimation() {
                this.isAnimating = true;
                this.currentJointIndex = 0;
                this.animationTime = 0;
                this.jointAngles.clear();
                document.getElementById('animateButton').style.background = '#f44336';
                document.getElementById('animateButton').textContent = 'Stop Animation';
                this.updateAnimationStatus();
            }

            stopAnimation() {
                this.isAnimating = false;
                document.getElementById('animateButton').style.background = '#2196F3';
                document.getElementById('animateButton').textContent = 'Animate Joints';
                document.getElementById('animationStatus').textContent = '';
                // Reset all joints to zero
                for (const [jointName, jointObject] of this.jointObjects) {
                    jointObject.rotation.set(0, 0, 0);
                }
            }

            updateAnimationStatus() {
                const status = document.getElementById('animationStatus');
                if (this.isAnimating) {
                    const jointNames = Array.from(this.jointObjects.keys());
                    const currentJoint = jointNames[this.currentJointIndex];
                    status.textContent = `Animating joint: ${currentJoint}`;
                }
            }

            updateJointAnimation() {
                const jointNames = Array.from(this.jointObjects.keys());
                const currentJoint = jointNames[this.currentJointIndex];
                const jointObject = this.jointObjects.get(currentJoint);
                
                if (jointObject) {
                    // Calculate angle based on time
                    const progress = this.animationTime / this.animationDuration;
                    let angle;
                    
                    if (progress < 0.5) {
                        // First half: 0 to 45 degrees
                        angle = (progress * 2) * Math.PI / 4;
                    } else {
                        // Second half: 45 to -45 degrees
                        angle = (1 - (progress - 0.5) * 2) * Math.PI / 4;
                    }
                    
                    // Apply rotation based on joint type
                    const jointData = this.urdfReader.robot.joints.get(currentJoint);
                    if (jointData) {
                        switch (jointData.type) {
                            case 'revolute':
                                // Apply rotation around the joint's axis
                                const axis = jointData.axis || [1, 0, 0];
                                jointObject.rotation.set(
                                    axis[0] * angle,
                                    axis[1] * angle,
                                    axis[2] * angle
                                );
                                break;
                            case 'continuous':
                                // Similar to revolute but can rotate continuously
                                const continuousAxis = jointData.axis || [1, 0, 0];
                                jointObject.rotation.set(
                                    continuousAxis[0] * angle,
                                    continuousAxis[1] * angle,
                                    continuousAxis[2] * angle
                                );
                                break;
                            // Add other joint types as needed
                        }
                    }
                }
            }

            clearRobot() {
                while(this.robotGroup.children.length > 0) {
                    this.robotGroup.remove(this.robotGroup.children[0]);
                }
            }

            createGeometry(geometryData) {
                if (!geometryData) return null;

                switch (geometryData.type) {
                    case 'box':
                        return new THREE.BoxGeometry(
                            geometryData.size[0],
                            geometryData.size[1],
                            geometryData.size[2]
                        );
                    case 'cylinder':
                        const geometry = new THREE.CylinderGeometry(
                            geometryData.radius,
                            geometryData.radius,
                            geometryData.length,
                            32
                        );
                        return geometry;
                    case 'sphere':
                        return new THREE.SphereGeometry(geometryData.radius, 32, 32);
                    case 'mesh':
                        // Handle mesh loading
                        if (geometryData.filename) {
                            const mesh = this.loadSTLMesh(geometryData.filename);
                            if (mesh) {
                                // Apply mesh scale if specified
                                if (geometryData.scale) {
                                    mesh.scale.set(
                                        geometryData.scale[0],
                                        geometryData.scale[1],
                                        geometryData.scale[2]
                                    );
                                }
                                return mesh;
                            }
                        }
                        return new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    default:
                        return new THREE.BoxGeometry(0.1, 0.1, 0.1);
                }
            }

            loadSTLMesh(filename) {
                // Create a placeholder geometry while loading
                const placeholder = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const material = new THREE.MeshPhongMaterial({ color: 0x808080 });
                const mesh = new THREE.Mesh(placeholder, material);

                // Load the actual STL file
                const timestamp = new Date().getTime();
                this.stlLoader.load(
                    `/models/${filename}?t=${timestamp}`,
                    (geometry) => {
                        mesh.geometry = geometry;
                        mesh.material = material;
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading STL:', error);
                    }
                );

                return mesh;
            }

            createMaterial(materialData) {
                if (!materialData) {
                    return new THREE.MeshPhongMaterial({ color: 0x808080 });
                }

                const color = materialData.color ? 
                    new THREE.Color(materialData.color[0], materialData.color[1], materialData.color[2]) :
                    new THREE.Color(0x808080);

                return new THREE.MeshPhongMaterial({ 
                    color: color,
                    opacity: materialData.color ? materialData.color[3] : 1,
                    transparent: materialData.color ? materialData.color[3] < 1 : false
                });
            }

            visualizeRobot(robotData) {
                this.clearRobot();
                this.jointObjects.clear();
                
                const linkObjects = new Map();
                const meshStatus = document.getElementById('meshStatus');
                meshStatus.textContent = 'Loading meshes...\n';

                // Create visual objects for each link
                for (const [linkName, linkData] of robotData.links) {
                    const linkGroup = new THREE.Group();
                    linkGroup.name = linkName;

                    if (linkData.visual) {
                        if (linkData.visual.geometry && linkData.visual.geometry.type === 'mesh') {
                            const filename = linkData.visual.geometry.filename;
                            // Only process STL files
                            if (filename.toLowerCase().endsWith('.stl')) {
                                meshStatus.textContent += `Loading ${filename}...\n`;
                                
                                this.stlLoader.load(
                                    `/public/models/${filename}?t=${Date.now()}`,
                                    (geometry) => {
                                        const material = new THREE.MeshPhongMaterial({ 
                                            color: 0x808080,
                                            shininess: 30,
                                            specular: 0x111111
                                        });
                                        const mesh = new THREE.Mesh(geometry, material);

                                        // Apply visual origin transform
                                        if (linkData.visual.origin) {
                                            const xyz = linkData.visual.origin.xyz;
                                            const rpy = linkData.visual.origin.rpy;
                                            mesh.position.set(xyz[0], xyz[1], xyz[2]);
                                            mesh.rotation.set(rpy[0], rpy[1], rpy[2]);
                                        }

                                        // Apply scale if specified
                                        if (linkData.visual.geometry.scale) {
                                            const scale = linkData.visual.geometry.scale;
                                            mesh.scale.set(scale[0], scale[1], scale[2]);
                                        }

                                        linkGroup.add(mesh);
                                        meshStatus.textContent += `✓ Loaded ${filename}\n`;
                                    },
                                    undefined,
                                    (error) => {
                                        console.error('Error loading STL:', error);
                                        meshStatus.textContent += `✗ Failed to load ${filename}\n`;
                                    }
                                );
                            } else {
                                meshStatus.textContent += `Skipping non-STL file: ${filename}\n`;
                            }
                        }
                    }

                    linkObjects.set(linkName, linkGroup);
                }

                // Build the tree structure
                for (const [jointName, jointData] of robotData.joints) {
                    const parentLink = linkObjects.get(jointData.parent);
                    const childLink = linkObjects.get(jointData.child);

                    if (parentLink && childLink) {
                        // Create a joint group for animation
                        const jointGroup = new THREE.Group();
                        jointGroup.name = jointName;
                        
                        // Apply joint transform
                        if (jointData.origin) {
                            const xyz = jointData.origin.xyz;
                            const rpy = jointData.origin.rpy;
                            childLink.position.set(xyz[0], xyz[1], xyz[2]);
                            childLink.rotation.set(rpy[0], rpy[1], rpy[2]);
                        }

                        jointGroup.add(childLink);
                        parentLink.add(jointGroup);
                        
                        // Store joint object for animation
                        this.jointObjects.set(jointName, jointGroup);
                    }
                }

                // Add root links to the scene
                for (const rootLink of robotData.rootLinks) {
                    const rootObject = linkObjects.get(rootLink);
                    if (rootObject) {
                        this.robotGroup.add(rootObject);
                    }
                }

                // Center and scale the robot
                const box = new THREE.Box3().setFromObject(this.robotGroup);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 5 / maxDim;
                
                this.robotGroup.position.copy(center).multiplyScalar(-1);
                this.robotGroup.scale.multiplyScalar(scale);
            }
        }

        // Initialize the visualizer
        const visualizer = new URDFVisualizer();

        // Setup event listeners
        document.getElementById('loadButton').addEventListener('click', () => {
            visualizer.loadSelectedModel();
        });

        document.getElementById('animateButton').addEventListener('click', () => {
            if (!visualizer.isAnimating) {
                visualizer.startAnimation();
            } else {
                visualizer.stopAnimation();
            }
        });
    </script>
</body>
</html> 
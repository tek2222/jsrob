<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URDF IK Explorer</title>
    <!-- Load Three.js and wait for it to be ready -->
    <script src="https://unpkg.com/three@0.140.0/build/three.min.js"></script>
    <script>
        // Wait for Three.js to load
        window.addEventListener('load', function() {
            // Load additional scripts after Three.js is ready
            function loadScript(src) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }

            Promise.all([
                loadScript('https://unpkg.com/three@0.140.0/examples/js/loaders/STLLoader.js'),
                loadScript('https://unpkg.com/three@0.140.0/examples/js/loaders/ColladaLoader.js'),
                loadScript('https://unpkg.com/three@0.140.0/examples/js/controls/OrbitControls.js'),
                loadScript('https://unpkg.com/three@0.140.0/examples/js/controls/TransformControls.js'),
                loadScript('js/urdf-utils.js'),
                loadScript('urdfreader.js')
            ]).then(() => {
                // Initialize the viewer after all scripts are loaded
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js failed to load');
                }
                if (typeof THREE.STLLoader === 'undefined') {
                    throw new Error('STLLoader failed to load');
                }
                if (typeof THREE.ColladaLoader === 'undefined') {
                    throw new Error('ColladaLoader failed to load');
                }
                if (typeof THREE.OrbitControls === 'undefined') {
                    throw new Error('OrbitControls failed to load');
                }
                // Initialize the visualizer
                window.visualizer = new URDFIKExplorer();
            }).catch(error => {
                console.error('Error loading scripts:', error);
                const debugConsole = document.getElementById('debugConsole');
                if (debugConsole) {
                    const timestamp = new Date().toLocaleTimeString();
                    debugConsole.innerHTML = `<div><span class="timestamp">[${timestamp}]</span> <span class="error">Error loading required scripts: ${error.message}</span></div>`;
                }
            });
        });
    </script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            gap: 20px;
            height: calc(100vh - 40px);
        }
        .controls {
            flex: 0 0 300px;
            min-width: 300px;
            max-width: 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }
        #webgl-container {
            flex: 1;
            min-width: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
            position: relative;
        }
        #timing-stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border-radius: 4px;
            z-index: 1000;
            pointer-events: none;
            white-space: pre;
        }
        select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background: #4CAF50;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 8px;
            transition: background-color 0.3s;
            font-size: 14px;
        }
        button:hover {
            opacity: 0.9;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        #loadingStatus {
            margin-top: 8px;
            color: #666;
            font-size: 12px;
        }
        #debugConsole {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 150px;
            background: rgba(30, 30, 30, 0.95);
            color: #00ff00;
            font-family: monospace;
            font-size: 11px;
            padding: 8px;
            overflow-y: auto;
            z-index: 1000;
            border-top: 2px solid #333;
        }
        #debugConsole .timestamp {
            color: #888;
            margin-right: 8px;
            font-size: 10px;
        }
        #debugConsole .error {
            color: #ff4444;
            font-weight: bold;
        }
        #debugConsole .warning {
            color: #ffaa00;
            font-weight: bold;
        }
        #debugConsole .success {
            color: #44ff44;
            font-weight: bold;
        }
        #debugConsole .info {
            color: #00ff00;
        }
        h2 {
            margin: 0 0 16px 0;
            font-size: 18px;
        }
        .controls > div {
            margin-bottom: 12px;
        }
        .slider-container {
            margin-top: 10px;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
        }
        .slider-container input {
            width: 100%;
        }
        .checkbox-container {
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .checkbox-container label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .checkbox-container input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        .control-group {
            margin-top: 16px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        .button-group {
            display: flex;
            gap: 8px;
        }
        .mode-button {
            flex: 1;
            background: #666;
            padding: 6px 12px;
        }
        .mode-button.active {
            background: #4CAF50;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h2>URDF IK Explorer</h2>
            <div>
                <select id="modelSelect">
                    <option value="">Select a robot model</option>
                </select>
                <button id="loadButton">Load Model</button>
                <div id="loadingStatus"></div>
            </div>
            <div class="slider-container">
                <label for="speedSlider">Exploration Speed (samples/frame):</label>
                <input type="range" id="speedSlider" min="1" max="500" value="50">
                <span id="speedValue">50</span>
            </div>
            <div class="slider-container">
                <label for="perturbationSlider">Perturbation Range (degrees):</label>
                <input type="range" id="perturbationSlider" min="0.1" max="180" step="0.1" value="10">
                <span id="perturbationValue">10.0</span>
            </div>
            <div class="slider-container">
                <label for="rotationWeightSlider">Rotation/Position Cost Ratio:</label>
                <input type="range" id="rotationWeightSlider" min="0" max="2" step="0.1" value="0.5">
                <span id="rotationWeightValue">0.5</span>
            </div>
            <div class="checkbox-container">
                <label>
                    <input type="checkbox" id="showFKPoints" checked>
                    Show FK Points
                </label>
            </div>
            <div class="checkbox-container">
                <label>
                    <input type="checkbox" id="showFKComparison">
                    Show FK Comparison Logs
                </label>
            </div>
            <div class="checkbox-container">
                <label>
                    <input type="checkbox" id="showFKTiming">
                    Show FK Timing Logs
                </label>
            </div>
            <div class="checkbox-container">
                <label>
                    <input type="checkbox" id="useFKFunction" checked>
                    Use FK Function (vs Direct Drawing)
                </label>
            </div>
            <div>
                <button id="toggleExploration">Start Exploration</button>
            </div>
            <div class="control-group">
                <label>Target Controls:</label>
                <div class="button-group">
                    <button id="translateMode" class="mode-button active">Translate</button>
                    <button id="rotateMode" class="mode-button">Rotate</button>
                </div>
            </div>
        </div>
        <div id="webgl-container">
            <div id="timing-stats"></div>
        </div>
    </div>
    <div id="debugConsole"></div>

    <script>
        class DebugLogger {
            constructor() {
                this.console = document.getElementById('debugConsole');
                if (!this.console) {
                    console.error('Debug console element not found!');
                    throw new Error('Debug console element not found');
                }
                this.log('Debug console initialized', 'success');
            }

            log(message, type = 'info') {
                if (!this.console) return;
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.innerHTML = `<span class="timestamp">[${timestamp}]</span> <span class="${type}">${message}</span>`;
                this.console.appendChild(entry);
                this.console.scrollTop = this.console.scrollHeight;
                console.log(`[${type}] ${message}`);
            }

            info(message) { this.log(message, 'info'); }
            success(message) { this.log(message, 'success'); }
            warning(message) { this.log(message, 'warning'); }
            error(message) { this.log(message, 'error'); }
            clear() { this.console.innerHTML = ''; }
        }

        class URDFIKExplorer {
            constructor() {
                this.logger = new DebugLogger();
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.robotModel = null;
                this.urdfReader = null;
                this.isExploring = false;
                this.samplesPerFrame = 10;
                this.perturbationRange = 10;
                this.rotationWeight = 0.5;
                this.controls = null;
                this.fkPoints = null;
                this.endEffectorName = null;
                this.showFKPoints = true;
                this.showFKComparison = false;
                this.showFKTiming = false;
                this.transformControls = null;
                this.targetPose = null;
                this.bestDistance = Infinity;
                this.bestJointAngles = new Map();
                this.currentJointAngles = new Map();
                this.viewerMarker = null;
                this.fkMarker = null;

                // Initialize utility classes
                this.robotVisualizer = null;
                this.robotKinematics = null;
                this.performanceMonitor = null;

                this.init();
                this.setupEventListeners();
                this.loadAvailableModels();
                this.animate();
            }

            init() {
                // Set up Three.js scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf3f4f6);

                // Add grid helper
                const gridHelper = new THREE.GridHelper(10, 10);
                gridHelper.rotation.x = Math.PI / 2; // Rotate for Z-up configuration
                this.scene.add(gridHelper);

                // Set up camera
                const container = document.getElementById('webgl-container');
                const aspect = container.clientWidth / container.clientHeight;
                this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
                this.camera.position.set(5, 5, 5);
                this.camera.up.set(0, 0, 1);
                this.camera.lookAt(0, 0, 0);

                // Set up renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(this.renderer.domElement);

                // Set up orbit controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;

                // Set up transform controls
                this.transformControls = new THREE.TransformControls(this.camera, this.renderer.domElement);
                this.transformControls.addEventListener('dragging-changed', (event) => {
                    this.controls.enabled = !event.value;
                });
                this.scene.add(this.transformControls);

                // Create target pose
                this.createTargetPose();

                // Add points for FK visualization
                const pointGeometry = new THREE.BufferGeometry();
                const pointMaterial = new THREE.PointsMaterial({
                    color: 0x00ff00,
                    size: 0.01,
                    sizeAttenuation: true,
                    opacity: 0.6,
                    transparent: true
                });
                this.fkPoints = new THREE.Points(pointGeometry, pointMaterial);
                this.scene.add(this.fkPoints);

                // Add lighting
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);

                // Initialize utility classes
                this.robotVisualizer = new RobotVisualizer(this.scene, this.logger);
                this.performanceMonitor = new PerformanceMonitor(this.logger);

                // Handle window resize
                window.addEventListener('resize', () => {
                    const container = document.getElementById('webgl-container');
                    const width = container.clientWidth;
                    const height = container.clientHeight;

                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(width, height);
                });
            }

            createTargetPose() {
                // Create a group for the target pose
                this.targetPose = new THREE.Group();
                
                // Create axes for the target pose (gnomon)
                const axesHelper = new THREE.AxesHelper(0.1); // Smaller axes
                this.targetPose.add(axesHelper);

                // Create a label for the target
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128; // Smaller canvas
                canvas.height = 32; // Smaller canvas
                context.fillStyle = '#ffffff';
                context.font = 'bold 24px Arial'; // Smaller font
                context.textAlign = 'center';
                context.fillText('Target', 64, 24);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(0.25, 0.0625, 1); // Smaller sprite
                sprite.position.set(0, 0, 0.15); // Position closer to axes
                this.targetPose.add(sprite);

                // Position the target pose
                this.targetPose.position.set(1, 1, 1);
                this.scene.add(this.targetPose);

                // Attach transform controls to target pose
                this.transformControls.attach(this.targetPose);
                this.transformControls.setMode('translate'); // Start in translate mode
                this.transformControls.setSize(0.8); // Make handles slightly smaller

                // Add change handler to update distance when target is moved
                this.transformControls.addEventListener('change', () => {
                    if (this.endEffectorName && this.robotModel) {
                        const endEffectorObject = this.findObjectByName(this.robotModel, this.endEffectorName);
                        if (endEffectorObject) {
                            const worldPos = new THREE.Vector3();
                            endEffectorObject.getWorldPosition(worldPos);
                            const distance = this.calculatePositionCost(worldPos);
                            // Update best distance if this configuration is better
                            if (distance < this.bestDistance) {
                                this.bestDistance = distance;
                                this.setBestSolution();
                                this.logger.success(`New best distance after target move: ${distance.toFixed(4)}`);
                            }
                            // Log current distance regardless
                            this.logger.info(`Current distance to target: ${distance.toFixed(4)}`);
                        }
                    }
                });
            }

            setupEventListeners() {
                // Load button
                const loadButton = document.getElementById('loadButton');
                loadButton.addEventListener('click', () => this.loadSelectedModel());

                // Toggle exploration button
                const toggleButton = document.getElementById('toggleExploration');
                toggleButton.addEventListener('click', () => {
                    if (this.isExploring) {
                        this.stopExploration();
                    } else {
                        this.startExploration();
                    }
                });

                // Speed slider
                const speedSlider = document.getElementById('speedSlider');
                const speedValue = document.getElementById('speedValue');
                speedSlider.addEventListener('input', () => {
                    this.samplesPerFrame = parseInt(speedSlider.value);
                    speedValue.textContent = this.samplesPerFrame;
                });

                // Perturbation slider
                const perturbationSlider = document.getElementById('perturbationSlider');
                const perturbationValue = document.getElementById('perturbationValue');
                perturbationSlider.addEventListener('input', () => {
                    this.perturbationRange = parseFloat(perturbationSlider.value);
                    perturbationValue.textContent = this.perturbationRange.toFixed(1);
                });

                // Rotation weight slider
                const rotationWeightSlider = document.getElementById('rotationWeightSlider');
                const rotationWeightValue = document.getElementById('rotationWeightValue');
                rotationWeightSlider.addEventListener('input', () => {
                    this.rotationWeight = parseFloat(rotationWeightSlider.value);
                    rotationWeightValue.textContent = this.rotationWeight.toFixed(1);
                });

                // FK Points visibility checkbox
                const showFKPointsCheckbox = document.getElementById('showFKPoints');
                showFKPointsCheckbox.addEventListener('change', () => {
                    this.showFKPoints = showFKPointsCheckbox.checked;
                    if (this.fkPoints) {
                        this.fkPoints.visible = this.showFKPoints;
                    }
                });

                // FK Comparison logging checkbox
                const showFKComparisonCheckbox = document.getElementById('showFKComparison');
                showFKComparisonCheckbox.addEventListener('change', () => {
                    this.showFKComparison = showFKComparisonCheckbox.checked;
                });

                // FK Timing logging checkbox
                const showFKTimingCheckbox = document.getElementById('showFKTiming');
                showFKTimingCheckbox.addEventListener('change', () => {
                    this.showFKTiming = showFKTimingCheckbox.checked;
                });

                // FK Function toggle checkbox
                const useFKFunctionCheckbox = document.getElementById('useFKFunction');
                useFKFunctionCheckbox.addEventListener('change', () => {
                    this.useFKFunction = useFKFunctionCheckbox.checked;
                });

                // Transform mode controls
                const translateButton = document.getElementById('translateMode');
                const rotateButton = document.getElementById('rotateMode');

                translateButton.addEventListener('click', () => {
                    this.transformControls.setMode('translate');
                    translateButton.classList.add('active');
                    rotateButton.classList.remove('active');
                });

                rotateButton.addEventListener('click', () => {
                    this.transformControls.setMode('rotate');
                    rotateButton.classList.add('active');
                    translateButton.classList.remove('active');
                });

                // Add keyboard shortcuts
                window.addEventListener('keydown', (event) => {
                    switch(event.key.toLowerCase()) {
                        case 'g':
                            // Translation mode
                            this.transformControls.setMode('translate');
                            translateButton.classList.add('active');
                            rotateButton.classList.remove('active');
                            break;
                        case 'r':
                            // Rotation mode
                            this.transformControls.setMode('rotate');
                            rotateButton.classList.add('active');
                            translateButton.classList.remove('active');
                            break;
                    }
                });
            }

            onWindowResize() {
                const container = document.getElementById('webgl-container');
                this.camera.aspect = container.clientWidth / container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(container.clientWidth, container.clientHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                if (this.isExploring && this.endEffectorName) {
                    const endEffectorObject = this.findObjectByName(this.robotModel, this.endEffectorName);
                    if (endEffectorObject) {
                        const worldPos = new THREE.Vector3();
                        endEffectorObject.getWorldPosition(worldPos);
                        const currentDistance = this.calculatePositionCost(worldPos);
                        
                        // Reset best distance if target has moved significantly
                        if (Math.abs(currentDistance - this.bestDistance) > 0.001) {
                            this.bestDistance = currentDistance;
                            // Store current configuration as our starting point
                            this.currentJointAngles = new Map();
                            for (const [jointName, jointData] of this.urdfReader.robot.joints) {
                                if (jointData.type === 'revolute' || jointData.type === 'prismatic') {
                                    this.currentJointAngles.set(jointName, this.urdfReader.getJointPosition(jointName));
                                }
                            }
                            this.bestJointAngles = new Map(this.currentJointAngles);
                        }

                        // Store the best configuration before exploration
                        const bestConfig = new Map(this.bestJointAngles);
                        const bestDist = this.bestDistance;

                        // Start timing for this frame's pose calculations
                        this.performanceMonitor.startFrame();

                        // Perform IK iterations in two phases
                        const totalSamples = this.samplesPerFrame;
                        const phase1Samples = Math.floor(totalSamples / 2);
                        const phase2Samples = totalSamples - phase1Samples;

                        // Phase 1: Coarse search with full perturbation range
                        for (let i = 0; i < phase1Samples; i++) {
                            const fkStartTime = performance.now();
                            this.randomizePose(1.0);
                            const fkEndTime = performance.now();
                            const costStartTime = performance.now();
                            const distance = this.calculatePositionCost(worldPos);
                            const costEndTime = performance.now();
                            
                            this.performanceMonitor.recordPoseCalculation(
                                fkEndTime - fkStartTime,
                                costEndTime - costStartTime
                            );

                            if (distance < this.bestDistance) {
                                this.bestDistance = distance;
                                this.setBestSolution();
                            }
                        }

                        // Phase 2: Fine search with reduced perturbation range
                        for (let i = 0; i < phase2Samples; i++) {
                            const fkStartTime = performance.now();
                            this.randomizePose(0.1);
                            const fkEndTime = performance.now();
                            const costStartTime = performance.now();
                            const distance = this.calculatePositionCost(worldPos);
                            const costEndTime = performance.now();
                            
                            this.performanceMonitor.recordPoseCalculation(
                                fkEndTime - fkStartTime,
                                costEndTime - costStartTime
                            );

                            if (distance < this.bestDistance) {
                                this.bestDistance = distance;
                                this.setBestSolution();
                            }
                        }

                        // Update frame statistics
                        this.performanceMonitor.updateFrameStats();

                        // Log performance stats and update timing display
                        const additionalStats = {
                            'Best distance': this.bestDistance.toFixed(4),
                            'Perturbation range': `±${this.perturbationRange}°`,
                            'Samples per frame': this.samplesPerFrame
                        };
                        this.performanceMonitor.logStats(additionalStats);
                        
                        // Update timing stats display
                        const stats = this.performanceMonitor.getStats();
                        const timingStats = document.getElementById('timing-stats');
                        if (timingStats) {
                            timingStats.textContent = 
`FPS: ${stats.fps.toFixed(0)}
Poses/frame: ${stats.posesPerFrame}
Avg time/pose: ${stats.avgTimePerPose.toFixed(2)}ms
├─ FK: ${stats.avgFKTimePerPose.toFixed(2)}ms
└─ Cost: ${stats.avgCostTimePerPose.toFixed(2)}ms
Best distance: ${this.bestDistance.toFixed(4)}`;
                        }

                        // If no better solution was found, restore the best configuration
                        if (this.bestDistance >= bestDist) {
                            this.bestDistance = bestDist;
                            this.bestJointAngles = bestConfig;
                            this.applyConfiguration(this.bestJointAngles);
                        }
                    }
                } else if (document.getElementById('timing-stats')) {
                    document.getElementById('timing-stats').textContent = 
`FPS: ${this.performanceMonitor ? this.performanceMonitor.getFPS().toFixed(0) : '--'}
(Exploration stopped)`;
                }

                // Update target pose label to face camera
                if (this.targetPose) {
                    const sprite = this.targetPose.children.find(child => child instanceof THREE.Sprite);
                    if (sprite) {
                        sprite.quaternion.copy(this.camera.quaternion);
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }

            calculatePositionCost(endEffectorPos) {
                if (!this.targetPose) return Infinity;
                
                const targetPos = new THREE.Vector3();
                this.targetPose.getWorldPosition(targetPos);
                
                const targetQuat = new THREE.Quaternion();
                this.targetPose.getWorldQuaternion(targetQuat);
                
                const endEffectorQuat = new THREE.Quaternion();
                const endEffectorObject = this.findObjectByName(this.robotModel, this.endEffectorName);
                if (endEffectorObject) {
                    endEffectorObject.getWorldQuaternion(endEffectorQuat);
                }
                
                return CostCalculator.calculateCombinedCost(
                    endEffectorPos,
                    targetPos,
                    endEffectorQuat,
                    targetQuat,
                    this.rotationWeight
                );
            }

            setBestSolution() {
                // Store current joint angles as best solution
                this.bestJointAngles.clear();
                for (const [jointName, jointData] of this.urdfReader.robot.joints) {
                    if (jointData.type === 'revolute' || jointData.type === 'prismatic') {
                        this.bestJointAngles.set(jointName, this.currentJointAngles.get(jointName));
                    }
                }
            }

            applyBestSolution() {
                if (this.bestJointAngles.size === 0) return;

                for (const [jointName, angle] of this.bestJointAngles) {
                    try {
                        this.urdfReader.setJointPosition(jointName, angle);
                        const jointObject = this.jointObjects.get(jointName);
                        if (jointObject) {
                            const jointData = this.urdfReader.robot.joints.get(jointName);
                            
                            // Reset transformation
                            jointObject.position.set(0, 0, 0);
                            jointObject.quaternion.set(0, 0, 0, 1);
                            
                            // Apply original transform from URDF
                            if (jointData.origin) {
                                const xyz = jointData.origin.xyz || [0, 0, 0];
                                const rpy = jointData.origin.rpy || [0, 0, 0];
                                jointObject.position.set(xyz[0], xyz[1], xyz[2]);
                                const euler = new THREE.Euler(rpy[0], rpy[1], rpy[2], 'XYZ');
                                jointObject.setRotationFromEuler(euler);
                            }
                            
                            // Apply joint rotation
                            const axis = jointData.axis || [0, 0, 1];
                            const axisVec = new THREE.Vector3(axis[0], axis[1], axis[2]).normalize();
                            const rotQuat = new THREE.Quaternion();
                            rotQuat.setFromAxisAngle(axisVec, angle);
                            jointObject.quaternion.multiply(rotQuat);

                            // Force update of matrix
                            jointObject.updateMatrix();
                            jointObject.updateMatrixWorld(true);
                        }
                    } catch (error) {
                        this.logger.error(`Error applying best solution for joint ${jointName}: ${error.message}`);
                    }
                }

                // Force update the entire robot's world matrix
                if (this.robotModel) {
                    this.robotModel.updateMatrixWorld(true);
                }
            }

            randomizePose(perturbationScale = 1.0) {
                if (!this.urdfReader || !this.jointObjects) return;

                // Track calculations
                this.totalFKCalculations++;
                
                // Store current configuration before trying new one
                const previousAngles = new Map();
                for (const [jointName, jointData] of this.urdfReader.robot.joints) {
                    if (jointData.type === 'revolute' || jointData.type === 'prismatic') {
                        previousAngles.set(jointName, this.urdfReader.getJointPosition(jointName));
                    }
                }

                // Calculate current distance before attempting new configuration
                let currentDistance = Infinity;
                if (this.endEffectorName) {
                    const endEffectorObject = this.findObjectByName(this.robotModel, this.endEffectorName);
                    if (endEffectorObject) {
                        const currentPos = new THREE.Vector3();
                        endEffectorObject.getWorldPosition(currentPos);
                        const costStartTime = performance.now();
                        currentDistance = this.calculatePositionCost(currentPos);
                        const costEndTime = performance.now();
                        this.costCalculationTime += costEndTime - costStartTime;
                    }
                }

                // Try a random configuration with scaled perturbation
                const perturbationRadians = (this.perturbationRange * Math.PI / 180.0) * perturbationScale;
                
                // Start timing for Three.js FK
                const threejsStartTime = performance.now();
                
                // Apply random configuration using Three.js
                for (const [jointName, jointData] of this.urdfReader.robot.joints) {
                    if (jointData.type !== 'revolute' && jointData.type !== 'prismatic') continue;
                    
                    const currentAngle = previousAngles.get(jointName);
                    const randomFloat = (Math.random() * 2.0 - 1.0);
                    const perturbation = randomFloat * perturbationRadians;
                    let newAngle = currentAngle + perturbation;
                    
                    if (jointData.limits) {
                        const lower = jointData.limits.lower;
                        const upper = jointData.limits.upper;
                        newAngle = Math.max(lower, Math.min(upper, newAngle));
                    }
                    
                    try {
                        this.urdfReader.setJointPosition(jointName, newAngle);
                        const jointObject = this.jointObjects.get(jointName);
                        if (jointObject) {
                            // Reset transformation
                            jointObject.position.set(0, 0, 0);
                            jointObject.quaternion.set(0, 0, 0, 1);
                            
                            // Apply original transform from URDF
                            if (jointData.origin) {
                                const xyz = jointData.origin.xyz || [0, 0, 0];
                                const rpy = jointData.origin.rpy || [0, 0, 0];
                                jointObject.position.set(xyz[0], xyz[1], xyz[2]);
                                const euler = new THREE.Euler(rpy[0], rpy[1], rpy[2], 'XYZ');
                                jointObject.setRotationFromEuler(euler);
                            }
                            
                            // Apply joint rotation
                            const axis = jointData.axis || [0, 0, 1];
                            const axisVec = new THREE.Vector3(axis[0], axis[1], axis[2]).normalize();
                            const rotQuat = new THREE.Quaternion();
                            rotQuat.setFromAxisAngle(axisVec, newAngle);
                            jointObject.quaternion.multiply(rotQuat);

                            jointObject.updateMatrix();
                            jointObject.updateMatrixWorld(true);
                        }
                    } catch (error) {
                        this.logger.error(`Error processing joint ${jointName}: ${error.message}`);
                    }
                }

                // Update robot's world matrix
                if (this.robotModel) {
                    this.robotModel.updateMatrixWorld(true);
                }

                const threejsEndTime = performance.now();
                const threejsTime = threejsEndTime - threejsStartTime;

                // Evaluate new configuration
                if (this.endEffectorName) {
                    const endEffectorObject = this.findObjectByName(this.robotModel, this.endEffectorName);
                    if (endEffectorObject) {
                        // Get viewer's direct world position from Three.js
                        const viewerWorldPos = new THREE.Vector3();
                        endEffectorObject.getWorldPosition(viewerWorldPos);

                        let fkResult = null;
                        let fkTime = 0;

                        if (this.useFKFunction) {
                            // Get our FK calculation
                            const currentAngles = new Map();
                            for (const [jointName, jointData] of this.urdfReader.robot.joints) {
                                if (jointData.type === 'revolute' || jointData.type === 'prismatic') {
                                    currentAngles.set(jointName, this.urdfReader.getJointPosition(jointName));
                                }
                            }

                            // Time our FK calculation
                            const fkStartTime = performance.now();
                            fkResult = this.calculateFK(currentAngles);
                            const fkEndTime = performance.now();
                            fkTime = fkEndTime - fkStartTime;
                        }

                        // Time the cost calculation
                        const costStartTime = performance.now();
                        const newDistance = this.calculatePositionCost(viewerWorldPos);
                        const costEndTime = performance.now();
                        this.costCalculationTime += costEndTime - costStartTime;

                        // Update visual comparison
                        if (fkResult) {
                            this.updateFKComparison(viewerWorldPos, fkResult.position);
                            
                            // Log timing comparison if enabled
                            if (this.showFKTiming) {
                                const posDiff = viewerWorldPos.distanceTo(fkResult.position);
                                this.logger.info(`=== FK Method Comparison ===
                                Method: ${this.useFKFunction ? 'FK Function' : 'Direct Drawing'}
                                Three.js FK time: ${threejsTime.toFixed(3)}ms
                                ${this.useFKFunction ? `Our FK time: ${fkTime.toFixed(3)}ms` : ''}
                                Cost calculation time: ${(costEndTime - costStartTime).toFixed(3)}ms
                                Position difference: ${posDiff.toFixed(6)}
                                Three.js position: (${viewerWorldPos.x.toFixed(4)}, ${viewerWorldPos.y.toFixed(4)}, ${viewerWorldPos.z.toFixed(4)})
                                ${this.useFKFunction ? `Our FK position: (${fkResult.position.x.toFixed(4)}, ${fkResult.position.y.toFixed(4)}, ${fkResult.position.z.toFixed(4)})` : ''}`);
                            }
                        }
                        
                        // Add FK point for visualization
                        this.addFKPoint(viewerWorldPos);

                        // If new position is better than our current best, keep it and update best
                        if (newDistance < this.bestDistance) {
                            this.bestDistance = newDistance;
                            // Store current configuration as best
                            this.bestJointAngles = new Map();
                            for (const [jointName, jointData] of this.urdfReader.robot.joints) {
                                if (jointData.type === 'revolute' || jointData.type === 'prismatic') {
                                    this.bestJointAngles.set(jointName, this.urdfReader.getJointPosition(jointName));
                                }
                            }
                            this.logger.success(`Found better solution! Distance: ${newDistance.toFixed(4)} (improved from ${currentDistance.toFixed(4)})`);
                            return;
                        }

                        // If the new solution is not better, restore the previous configuration
                        this.applyConfiguration(previousAngles);
                        
                        // Verify we restored correctly
                        const verifyPos = new THREE.Vector3();
                        endEffectorObject.getWorldPosition(verifyPos);
                        const verifyDistance = this.calculatePositionCost(verifyPos);
                        
                        if (Math.abs(verifyDistance - currentDistance) > 0.0001) {
                            this.logger.warning(`Distance verification failed! Expected ${currentDistance.toFixed(6)} but got ${verifyDistance.toFixed(6)}`);
                            // As a fallback, apply our known best configuration
                            this.applyConfiguration(this.bestJointAngles);
                        }
                    }
                }
            }

            applyConfiguration(jointAngles) {
                for (const [jointName, angle] of jointAngles) {
                    try {
                        this.urdfReader.setJointPosition(jointName, angle);
                        const jointObject = this.jointObjects.get(jointName);
                        if (jointObject) {
                            const jointData = this.urdfReader.robot.joints.get(jointName);
                            TransformationUtils.applyJointTransform(jointObject, jointData, angle);
                        }
                    } catch (error) {
                        this.logger.error(`Error applying configuration for joint ${jointName}: ${error.message}`);
                    }
                }

                // Force update the entire robot's world matrix
                if (this.robotModel) {
                    this.robotModel.updateMatrixWorld(true);
                }
            }

            findObjectByName(object, name) {
                if (object.name === name) return object;
                for (const child of object.children) {
                    const found = this.findObjectByName(child, name);
                    if (found) return found;
                }
                return null;
            }

            addFKPoint(position) {
                // Only add points if visualization is enabled
                if (!this.showFKPoints) return;

                // Initialize points array if not exists
                if (!this.fkPointsArray) {
                    this.fkPointsArray = [];
                    this.currentPointIndex = 0;
                }

                const maxPoints = 1000; // Reduced from 10000 to 1000 for better performance

                // Add new point to array
                if (this.fkPointsArray.length < maxPoints) {
                    this.fkPointsArray.push(new THREE.Vector3(position.x, position.y, position.z));
                } else {
                    // Reuse existing point at current index
                    this.fkPointsArray[this.currentPointIndex].copy(position);
                    this.currentPointIndex = (this.currentPointIndex + 1) % maxPoints;
                }

                // Update geometry
                const positions = new Float32Array(this.fkPointsArray.length * 3);
                for (let i = 0; i < this.fkPointsArray.length; i++) {
                    const point = this.fkPointsArray[i];
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                }

                // Create new buffer geometry
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                // Update or create points object
                if (this.fkPoints) {
                    this.fkPoints.geometry.dispose(); // Clean up old geometry
                    this.fkPoints.geometry = geometry;
                } else {
                    const material = new THREE.PointsMaterial({
                        color: 0x00ff00,
                        size: 0.01,
                        sizeAttenuation: true,
                        opacity: 0.6,
                        transparent: true
                    });
                    this.fkPoints = new THREE.Points(geometry, material);
                    this.scene.add(this.fkPoints);
                }
            }

            startExploration() {
                if (!this.urdfReader) {
                    this.logger.warning('No robot model loaded');
                    return;
                }

                // Reset counters and best solution
                this.totalFKCalculations = 0;
                this.lastLogTime = Date.now();
                this.bestDistance = Infinity;
                this.bestJointAngles.clear();
                this.currentJointAngles.clear();

                // Clear existing FK points
                if (this.fkPoints) {
                    this.fkPoints.geometry.dispose(); // Clean up old geometry
                    this.fkPoints.geometry = new THREE.BufferGeometry();
                    this.fkPointsArray = []; // Reset points array
                    this.currentPointIndex = 0;
                }

                this.isExploring = true;
                const toggleButton = document.getElementById('toggleExploration');
                toggleButton.textContent = 'Stop Exploration';
                toggleButton.style.background = '#f44336';
                this.logger.info('Started IK exploration');
            }

            stopExploration() {
                this.isExploring = false;
                const toggleButton = document.getElementById('toggleExploration');
                toggleButton.textContent = 'Start Exploration';
                toggleButton.style.background = '#4CAF50';
                
                // Clean up FK points when stopping
                if (this.fkPoints) {
                    this.fkPoints.geometry.dispose();
                    this.fkPoints.geometry = new THREE.BufferGeometry();
                    this.fkPointsArray = [];
                    this.currentPointIndex = 0;
                }
                
                this.logger.info('Stopped IK exploration');
            }

            async loadAvailableModels() {
                try {
                    this.logger.info('Starting to load URDF models from server...');
                    const timestamp = new Date().getTime();
                    const url = `/api/models?t=${timestamp}`;
                    this.logger.info(`Fetching models from: ${url}`);
                    
                    const response = await fetch(url);
                    this.logger.info(`Server response status: ${response.status} ${response.statusText}`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const text = await response.text();
                    this.logger.info(`Raw server response: ${text}`);
                    
                    if (!text) {
                        throw new Error('Empty response from server');
                    }
                    
                    const models = JSON.parse(text);
                    this.logger.success(`Found ${models.length} URDF models on server`);
                    
                    const select = document.getElementById('modelSelect');
                    if (!select) {
                        throw new Error('Could not find modelSelect element in DOM');
                    }
                    
                    select.innerHTML = '<option value="">Select a model...</option>';
                    
                    if (!Array.isArray(models) || models.length === 0) {
                        this.logger.warning('No URDF models found on server');
                        select.innerHTML = '<option value="">No models available</option>';
                        return;
                    }
                    
                    models.forEach(model => {
                        if (!model.name || !model.urdf) {
                            this.logger.warning(`Invalid model data received: ${JSON.stringify(model)}`);
                            return;
                        }
                        const option = document.createElement('option');
                        option.value = model.urdf;
                        option.textContent = model.name;
                        select.appendChild(option);
                        this.logger.info(`Added model to dropdown: ${model.name}`);
                    });
                    
                    this.logger.success(`Successfully populated dropdown with ${models.length} URDF models`);
                } catch (error) {
                    this.logger.error(`Failed to load models from server: ${error.message}`);
                    const select = document.getElementById('modelSelect');
                    if (select) {
                        select.innerHTML = '<option value="">Error loading models</option>';
                    }
                }
            }

            async loadSelectedModel() {
                const modelSelect = document.getElementById('modelSelect');
                const modelFile = modelSelect ? modelSelect.value : '';
                
                if (!modelFile) {
                    this.logger.warning('No model selected in dropdown');
                    alert('Please select a model first');
                    return;
                }

                const loadingStatus = document.getElementById('loadingStatus');
                const loadButton = document.getElementById('loadButton');
                
                try {
                    this.logger.info(`Starting to load URDF model: ${modelFile}`);
                    loadingStatus.textContent = 'Loading URDF...';
                    loadButton.disabled = true;

                    // Clear existing robot
                    if (this.robotModel) {
                        this.scene.remove(this.robotModel);
                        this.robotModel = null;
                    }

                    // Create new robot model group
                    this.robotModel = new THREE.Group();
                    this.scene.add(this.robotModel);

                    // Load and parse URDF
                    this.urdfReader = new URDFReader();
                    const robotData = await this.urdfReader.loadModelFromFile(modelFile);
                    this.logger.success(`Successfully parsed URDF for robot: ${robotData.name}`);
                    await this.visualizeRobot(robotData);

                    loadingStatus.textContent = 'Model loaded successfully';
                    this.logger.success('Robot model loaded');
                } catch (error) {
                    console.error('Error:', error);
                    this.logger.error(`Failed to load model: ${error.message}`);
                    this.logger.error('Stack trace: ' + error.stack);
                    loadingStatus.textContent = 'Error loading model: ' + error.message;
                } finally {
                    loadButton.disabled = false;
                }
            }

            async visualizeRobot(robotData) {
                this.logger.info('Starting robot visualization...');
                
                // Clear existing robot
                if (this.robotModel) {
                    this.scene.remove(this.robotModel);
                }
                
                // Initialize utility classes
                this.robotVisualizer = new RobotVisualizer(this.scene, this.logger);
                this.robotModel = await this.robotVisualizer.visualizeRobot(robotData);
                this.jointObjects = this.robotVisualizer.jointObjects;
                
                // Calculate bounding box and adjust camera
                const box = new THREE.Box3().setFromObject(this.robotModel);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Reset robot position and rotation
                this.robotModel.position.set(0, 0, 0);
                this.robotModel.rotation.set(0, 0, 0);
                this.robotModel.updateMatrixWorld(true);

                // Recalculate bounding box after reset
                box.setFromObject(this.robotModel);
                box.getSize(size);
                box.getCenter(center);

                // Center the robot and place it on the ground
                this.robotModel.position.set(-center.x, -center.y, -box.min.z);
                this.robotModel.updateMatrixWorld(true);

                // Calculate camera distance based on robot size
                const maxDim = Math.max(size.x, size.y, size.z);
                const distance = maxDim * 2;
                
                // Position camera for proper Z-up view
                this.camera.position.set(distance, distance, distance);
                this.camera.up.set(0, 0, 1);
                this.camera.lookAt(0, 0, 0);

                // Adjust camera parameters
                this.camera.near = distance * 0.01;
                this.camera.far = distance * 10;
                this.camera.fov = 45;
                this.camera.updateProjectionMatrix();

                // Reset controls
                this.controls.target.set(0, 0, 0);
                this.controls.update();

                // Find the end effector (last link in the chain)
                const links = Array.from(robotData.links.keys());
                this.endEffectorName = links[links.length - 1];
                this.logger.info(`Set end effector to: ${this.endEffectorName}`);

                // Initialize RobotKinematics
                this.robotKinematics = new RobotKinematics(robotData, this.endEffectorName);

                // Initialize PerformanceMonitor
                this.performanceMonitor = new PerformanceMonitor(this.logger);

                this.logger.success('Robot visualization complete');
            }

            calculateFK(jointAngles) {
                if (!this.robotKinematics) return null;
                return this.robotKinematics.calculateFK(jointAngles, this.robotModel.position);
            }

            createPositionMarker(color) {
                const geometry = new THREE.SphereGeometry(0.02);
                const material = new THREE.MeshBasicMaterial({ color: color });
                return new THREE.Mesh(geometry, material);
            }

            updateFKComparison(viewerWorldPos, fkPos) {
                // Create markers if they don't exist
                if (!this.viewerMarker) {
                    this.viewerMarker = this.createPositionMarker(0x00ff00); // Green for viewer
                    this.scene.add(this.viewerMarker);
                }
                if (!this.fkMarker) {
                    this.fkMarker = this.createPositionMarker(0xff0000); // Red for FK
                    this.scene.add(this.fkMarker);
                }

                // Update marker positions
                this.viewerMarker.position.copy(viewerWorldPos);
                this.fkMarker.position.copy(fkPos);

                // Only log if comparison logging is enabled
                if (this.showFKComparison) {
                    const posDiff = viewerWorldPos.distanceTo(fkPos);
                    this.logger.info(`=== FK Comparison ===
                    Viewer pos: (${viewerWorldPos.x.toFixed(4)}, ${viewerWorldPos.y.toFixed(4)}, ${viewerWorldPos.z.toFixed(4)})
                    FK pos: (${fkPos.x.toFixed(4)}, ${fkPos.y.toFixed(4)}, ${fkPos.z.toFixed(4)})
                    Difference: ${posDiff.toFixed(6)}`);
                }
            }

            updateTimingStats() {
                const timingStats = document.getElementById('timing-stats');
                if (!timingStats) return;

                // Calculate FPS
                const now = performance.now();
                this.frameCount++;
                
                if (now - this.lastFPSUpdate >= 1000) {
                    this.lastFPS = Math.round((this.frameCount * 1000) / (now - this.lastFPSUpdate));
                    this.frameCount = 0;
                    this.lastFPSUpdate = now;
                }

                if (this.isExploring) {
                    timingStats.textContent = 
`FPS: ${this.lastFPS}
Poses/frame: ${this.framePoseCount}
Avg time/pose: ${this.avgTimePerPose.toFixed(2)}ms
├─ FK: ${this.avgFKTimePerPose.toFixed(2)}ms
└─ Cost: ${this.avgCostTimePerPose.toFixed(2)}ms
Best distance: ${this.bestDistance.toFixed(4)}`;
                } else {
                    timingStats.textContent = 
`FPS: ${this.lastFPS}
(Exploration stopped)`;
                }
            }
        }
    </script>
</body>
</html> 